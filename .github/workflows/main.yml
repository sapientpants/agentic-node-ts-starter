name: Main

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write
  attestations: write
  security-events: write
  actions: read

env:
  PNPM_VERSION: 10.0.0
  NODE_VERSION: 22

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Get author info
        id: author
        run: |
          # Get the author info from the commit that triggered the workflow
          AUTHOR_NAME="${{ github.actor }}"

          # Try to get the public email from GitHub API
          PUBLIC_EMAIL=$(gh api users/${{ github.actor }} --jq '.email // empty' 2>/dev/null || echo "")

          if [ -n "$PUBLIC_EMAIL" ] && [ "$PUBLIC_EMAIL" != "null" ]; then
            AUTHOR_EMAIL="$PUBLIC_EMAIL"
          else
            # Fall back to noreply email
            AUTHOR_EMAIL="${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"
          fi

          # Try to get the real email from the last commit if available
          if [ "${{ github.event_name }}" == "push" ]; then
            COMMIT_AUTHOR_NAME=$(git log -1 --pretty=format:'%an' ${{ github.sha }} 2>/dev/null || echo "")
            COMMIT_AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae' ${{ github.sha }} 2>/dev/null || echo "")
            if [ -n "$COMMIT_AUTHOR_NAME" ] && [ -n "$COMMIT_AUTHOR_EMAIL" ]; then
              AUTHOR_NAME="$COMMIT_AUTHOR_NAME"
              AUTHOR_EMAIL="$COMMIT_AUTHOR_EMAIL"
            fi
          fi

          echo "name=$AUTHOR_NAME" >> $GITHUB_OUTPUT
          echo "email=$AUTHOR_EMAIL" >> $GITHUB_OUTPUT
          echo "üë§ Author: $AUTHOR_NAME <$AUTHOR_EMAIL>"

      - name: Check for changeset
        id: check-changeset
        run: |
          # Check for existing changesets
          if [ -d ".changeset" ] && ls .changeset/*.md 2>/dev/null | grep -v README.md > /dev/null; then
            echo "has_changeset=true" >> $GITHUB_OUTPUT
            echo "üì¶ Found existing changeset"
          else
            echo "has_changeset=false" >> $GITHUB_OUTPUT
            
            # Get commits since last tag
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LAST_TAG" ]; then
              COMMIT_RANGE="HEAD"
            else
              COMMIT_RANGE="$LAST_TAG..HEAD"
            fi
            
            # Check if there are any feat/fix commits that would require a release
            if git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^(feat|fix|perf|refactor)(\(.+\))?:" > /dev/null; then
              echo "‚ùå Error: Found releasable commits but no changeset"
              echo "Commits that require a changeset:"
              git log $COMMIT_RANGE --pretty=format:"  - %s" | grep -E "^  - (feat|fix|perf|refactor)(\(.+\))?:"
              echo ""
              echo "Please add a changeset by running: pnpm changeset"
              exit 1
            else
              echo "‚è≠Ô∏è No releasable commits found, skipping release"
              echo "skip_release=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Version packages
        id: version
        if: steps.check-changeset.outputs.skip_release != 'true'
        run: |
          # Get current version before changes
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"

          # Apply changesets (this updates package.json and CHANGELOG.md)
          pnpm changeset version

          # Get new version after changes
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "New version: $NEW_VERSION"

          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "üì¶ Version changed to: $NEW_VERSION"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No version change"
          fi

      - name: Build
        if: steps.version.outputs.changed == 'true'
        run: pnpm build

      - name: Generate SBOM
        if: steps.version.outputs.changed == 'true'
        run: pnpm sbom

      - name: Create build artifacts
        if: steps.version.outputs.changed == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          # Create tarball of dist folder
          tar -czf dist-${VERSION}.tar.gz dist/

          # Create zip of dist folder
          zip -r dist-${VERSION}.zip dist/

      - name: Commit and tag via GitHub API
        if: steps.version.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.github-token }}
          script: |
            const fs = require('fs');
            const version = '${{ steps.version.outputs.version }}';
            const authorName = '${{ steps.author.outputs.name }}';
            const authorEmail = '${{ steps.author.outputs.email }}';

            // Read the changed files
            const filesToCommit = [
              'package.json',
              'CHANGELOG.md',
              '.changeset'
            ];

            // Get the current commit SHA (parent commit)
            const { data: refData } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });
            const parentSha = refData.object.sha;

            // Get the current tree
            const { data: parentCommit } = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: parentSha
            });

            // Create blobs for changed files
            const blobs = [];
            for (const filePath of filesToCommit) {
              try {
                let content;
                const stats = fs.statSync(filePath);
                
                if (stats.isDirectory()) {
                  // Handle directory deletion (changesets)
                  continue;
                } else {
                  content = fs.readFileSync(filePath, 'utf8');
                }
                
                const { data: blob } = await github.rest.git.createBlob({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  content: Buffer.from(content).toString('base64'),
                  encoding: 'base64'
                });
                
                blobs.push({
                  path: filePath,
                  mode: '100644',
                  type: 'blob',
                  sha: blob.sha
                });
              } catch (e) {
                // File might not exist or be deleted, skip it
                console.log(`Skipping ${filePath}: ${e.message}`);
              }
            }

            // Create a new tree
            const { data: newTree } = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base_tree: parentCommit.tree.sha,
              tree: blobs
            });

            // Create the commit
            const commitMessage = `chore(release): v${version}`;
            const { data: newCommit } = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: commitMessage,
              tree: newTree.sha,
              parents: [parentSha],
              author: {
                name: authorName,
                email: authorEmail,
                date: new Date().toISOString()
              },
              committer: {
                name: authorName,
                email: authorEmail,
                date: new Date().toISOString()
              }
            });

            // Update the main branch reference
            await github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main',
              sha: newCommit.sha
            });

            // Create the tag
            const { data: tag } = await github.rest.git.createTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: `v${version}`,
              message: `Release v${version}`,
              object: newCommit.sha,
              type: 'commit',
              tagger: {
                name: authorName,
                email: authorEmail,
                date: new Date().toISOString()
              }
            });

            // Create the tag reference
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/v${version}`,
              sha: newCommit.sha
            });

            console.log(`‚úÖ Created commit ${newCommit.sha} and tag v${version}`);
            console.log(`üë§ Author: ${authorName} <${authorEmail}>`);

      - name: Extract release notes
        if: steps.version.outputs.changed == 'true'
        run: |
          # Extract changelog for this version
          VERSION="${{ steps.version.outputs.version }}"
          awk -v version="## $VERSION" '
            $0 ~ version { flag=1; next }
            /^## [0-9]/ && flag { exit }
            flag { print }
          ' CHANGELOG.md > release-notes.md

          # If release notes are empty, use a default message
          if [ ! -s release-notes.md ]; then
            echo "Release v$VERSION" > release-notes.md
          fi

      - name: Create GitHub Release
        if: steps.version.outputs.changed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: v${{ steps.version.outputs.version }}
          body_path: release-notes.md
          files: |
            sbom.cdx.json
            dist-${{ steps.version.outputs.version }}.tar.gz
            dist-${{ steps.version.outputs.version }}.zip
          draft: false
          prerelease: false
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}

      - name: Generate attestations
        if: steps.version.outputs.changed == 'true'
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            dist/**/*.js
            sbom.cdx.json
            dist-*.tar.gz
            dist-*.zip

      - name: Mark as released
        id: release
        if: steps.version.outputs.changed == 'true'
        run: |
          echo "released=true" >> $GITHUB_OUTPUT
          echo "version=${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Released version ${{ steps.version.outputs.version }}"
